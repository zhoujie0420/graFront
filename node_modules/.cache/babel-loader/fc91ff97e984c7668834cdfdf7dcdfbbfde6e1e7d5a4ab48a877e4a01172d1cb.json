{"ast":null,"code":"import { createVNode as _createVNode } from \"vue\";\nimport { ref, watch, computed, reactive, defineComponent } from \"vue\";\nimport { clamp, numericProp, preventDefault, createNamespace, makeRequiredProp, LONG_PRESS_START_TIME, TAP_OFFSET } from \"../utils/index.mjs\";\nimport { useTouch } from \"../composables/use-touch.mjs\";\nimport { raf, useEventListener, useRect } from \"@vant/use\";\nimport { Image } from \"../image/index.mjs\";\nimport { Loading } from \"../loading/index.mjs\";\nimport { SwipeItem } from \"../swipe-item/index.mjs\";\nconst getDistance = touches => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\nconst getCenter = touches => ({\n  x: (touches[0].clientX + touches[1].clientX) / 2,\n  y: (touches[0].clientY + touches[1].clientY) / 2\n});\nconst bem = createNamespace(\"image-preview\")[1];\nconst longImageRatio = 2.6;\nvar stdin_default = defineComponent({\n  props: {\n    src: String,\n    show: Boolean,\n    active: Number,\n    minZoom: makeRequiredProp(numericProp),\n    maxZoom: makeRequiredProp(numericProp),\n    rootWidth: makeRequiredProp(Number),\n    rootHeight: makeRequiredProp(Number),\n    disableZoom: Boolean,\n    closeOnClickOverlay: Boolean\n  },\n  emits: [\"scale\", \"close\", \"longPress\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const state = reactive({\n      scale: 1,\n      moveX: 0,\n      moveY: 0,\n      moving: false,\n      zooming: false,\n      initializing: false,\n      imageRatio: 0\n    });\n    const touch = useTouch();\n    const imageRef = ref();\n    const swipeItem = ref();\n    const vertical = ref(false);\n    const isLongImage = ref(false);\n    let initialMoveY = 0;\n    const imageStyle = computed(() => {\n      const {\n        scale,\n        moveX,\n        moveY,\n        moving,\n        zooming,\n        initializing\n      } = state;\n      const style = {\n        transitionDuration: zooming || moving || initializing ? \"0s\" : \".3s\"\n      };\n      if (scale !== 1 || isLongImage.value) {\n        style.transform = `matrix(${scale}, 0, 0, ${scale}, ${moveX}, ${moveY})`;\n      }\n      return style;\n    });\n    const maxMoveX = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;\n        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);\n      }\n      return 0;\n    });\n    const maxMoveY = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;\n        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);\n      }\n      return 0;\n    });\n    const setScale = (scale, center) => {\n      var _a;\n      scale = clamp(scale, +props.minZoom, +props.maxZoom + 1);\n      if (scale !== state.scale) {\n        const ratio = scale / state.scale;\n        state.scale = scale;\n        if (center) {\n          const imageRect = useRect((_a = imageRef.value) == null ? void 0 : _a.$el);\n          const origin = {\n            x: imageRect.width * 0.5,\n            y: imageRect.height * 0.5\n          };\n          const moveX = state.moveX - (center.x - imageRect.left - origin.x) * (ratio - 1);\n          const moveY = state.moveY - (center.y - imageRect.top - origin.y) * (ratio - 1);\n          state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n          state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n        } else {\n          state.moveX = 0;\n          state.moveY = isLongImage.value ? initialMoveY : 0;\n        }\n        emit(\"scale\", {\n          scale,\n          index: props.active\n        });\n      }\n    };\n    const resetScale = () => {\n      setScale(1);\n    };\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n      setScale(scale, scale === 2 || isLongImage.value ? {\n        x: touch.startX.value,\n        y: touch.startY.value\n      } : void 0);\n    };\n    let fingerNum;\n    let startMoveX;\n    let startMoveY;\n    let startScale;\n    let startDistance;\n    let lastCenter;\n    let doubleTapTimer;\n    let touchStartTime;\n    let isImageMoved = false;\n    const onTouchStart = event => {\n      const {\n        touches\n      } = event;\n      fingerNum = touches.length;\n      if (fingerNum === 2 && props.disableZoom) {\n        return;\n      }\n      const {\n        offsetX\n      } = touch;\n      touch.start(event);\n      startMoveX = state.moveX;\n      startMoveY = state.moveY;\n      touchStartTime = Date.now();\n      isImageMoved = false;\n      state.moving = fingerNum === 1 && (state.scale !== 1 || isLongImage.value);\n      state.zooming = fingerNum === 2 && !offsetX.value;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(touches);\n      }\n    };\n    const onTouchMove = event => {\n      const {\n        touches\n      } = event;\n      touch.move(event);\n      if (state.moving) {\n        const {\n          deltaX,\n          deltaY\n        } = touch;\n        const moveX = deltaX.value + startMoveX;\n        const moveY = deltaY.value + startMoveY;\n        if ((moveX > maxMoveX.value || moveX < -maxMoveX.value) && !isImageMoved && touch.isHorizontal()) {\n          state.moving = false;\n          return;\n        }\n        isImageMoved = true;\n        preventDefault(event, true);\n        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n      }\n      if (state.zooming) {\n        preventDefault(event, true);\n        if (touches.length === 2) {\n          const distance = getDistance(touches);\n          const scale = startScale * distance / startDistance;\n          lastCenter = getCenter(touches);\n          setScale(scale, lastCenter);\n        }\n      }\n    };\n    const checkTap = event => {\n      var _a;\n      if (fingerNum > 1) {\n        return;\n      }\n      const {\n        offsetX,\n        offsetY\n      } = touch;\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET) {\n        if (deltaTime < TAP_TIME) {\n          if (doubleTapTimer) {\n            clearTimeout(doubleTapTimer);\n            doubleTapTimer = null;\n            toggleScale();\n          } else {\n            if (!props.closeOnClickOverlay && event.target === ((_a = swipeItem.value) == null ? void 0 : _a.$el)) {\n              return;\n            }\n            doubleTapTimer = setTimeout(() => {\n              emit(\"close\");\n              doubleTapTimer = null;\n            }, TAP_TIME);\n          }\n        } else if (deltaTime > LONG_PRESS_START_TIME) {\n          emit(\"longPress\");\n        }\n      }\n    };\n    const onTouchEnd = event => {\n      let stopPropagation = false;\n      if (state.moving || state.zooming) {\n        stopPropagation = true;\n        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {\n          stopPropagation = false;\n        }\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);\n            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);\n            state.zooming = false;\n          }\n          state.moving = false;\n          startMoveX = 0;\n          startMoveY = 0;\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          const maxZoom = +props.maxZoom;\n          if (state.scale > maxZoom) {\n            setScale(maxZoom, lastCenter);\n          }\n        }\n      }\n      preventDefault(event, stopPropagation);\n      checkTap(event);\n      touch.reset();\n    };\n    const resize = () => {\n      const {\n        rootWidth,\n        rootHeight\n      } = props;\n      const rootRatio = rootHeight / rootWidth;\n      const {\n        imageRatio\n      } = state;\n      vertical.value = state.imageRatio > rootRatio && imageRatio < longImageRatio;\n      isLongImage.value = state.imageRatio > rootRatio && imageRatio >= longImageRatio;\n      if (isLongImage.value) {\n        initialMoveY = (imageRatio * rootWidth - rootHeight) / 2;\n        state.moveY = initialMoveY;\n        state.initializing = true;\n        raf(() => {\n          state.initializing = false;\n        });\n      }\n      resetScale();\n    };\n    const onLoad = event => {\n      const {\n        naturalWidth,\n        naturalHeight\n      } = event.target;\n      state.imageRatio = naturalHeight / naturalWidth;\n      resize();\n    };\n    watch(() => props.active, resetScale);\n    watch(() => props.show, value => {\n      if (!value) {\n        resetScale();\n      }\n    });\n    watch(() => [props.rootWidth, props.rootHeight], resize);\n    useEventListener(\"touchmove\", onTouchMove, {\n      target: computed(() => {\n        var _a;\n        return (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      })\n    });\n    return () => {\n      const imageSlots = {\n        loading: () => _createVNode(Loading, {\n          \"type\": \"spinner\"\n        }, null)\n      };\n      return _createVNode(SwipeItem, {\n        \"ref\": swipeItem,\n        \"class\": bem(\"swipe-item\"),\n        \"onTouchstartPassive\": onTouchStart,\n        \"onTouchend\": onTouchEnd,\n        \"onTouchcancel\": onTouchEnd\n      }, {\n        default: () => [slots.image ? _createVNode(\"div\", {\n          \"class\": bem(\"image-wrap\")\n        }, [slots.image({\n          src: props.src\n        })]) : _createVNode(Image, {\n          \"ref\": imageRef,\n          \"src\": props.src,\n          \"fit\": \"contain\",\n          \"class\": bem(\"image\", {\n            vertical: vertical.value\n          }),\n          \"style\": imageStyle.value,\n          \"onLoad\": onLoad\n        }, imageSlots)]\n      });\n    };\n  }\n});\nexport { stdin_default as default };","map":{"version":3,"names":["createVNode","_createVNode","ref","watch","computed","reactive","defineComponent","clamp","numericProp","preventDefault","createNamespace","makeRequiredProp","LONG_PRESS_START_TIME","TAP_OFFSET","useTouch","raf","useEventListener","useRect","Image","Loading","SwipeItem","getDistance","touches","Math","sqrt","clientX","clientY","getCenter","x","y","bem","longImageRatio","stdin_default","props","src","String","show","Boolean","active","Number","minZoom","maxZoom","rootWidth","rootHeight","disableZoom","closeOnClickOverlay","emits","setup","emit","slots","state","scale","moveX","moveY","moving","zooming","initializing","imageRatio","touch","imageRef","swipeItem","vertical","isLongImage","initialMoveY","imageStyle","style","transitionDuration","value","transform","maxMoveX","displayWidth","max","maxMoveY","displayHeight","setScale","center","_a","ratio","imageRect","$el","origin","width","height","left","top","index","resetScale","toggleScale","startX","startY","fingerNum","startMoveX","startMoveY","startScale","startDistance","lastCenter","doubleTapTimer","touchStartTime","isImageMoved","onTouchStart","event","length","offsetX","start","Date","now","onTouchMove","move","deltaX","deltaY","isHorizontal","distance","checkTap","offsetY","deltaTime","TAP_TIME","clearTimeout","target","setTimeout","onTouchEnd","stopPropagation","reset","resize","rootRatio","onLoad","naturalWidth","naturalHeight","imageSlots","loading","default","image"],"sources":["/Users/jiezhou/IdeaProjects/web/node_modules/vant/es/image-preview/ImagePreviewItem.mjs"],"sourcesContent":["import { createVNode as _createVNode } from \"vue\";\nimport { ref, watch, computed, reactive, defineComponent } from \"vue\";\nimport { clamp, numericProp, preventDefault, createNamespace, makeRequiredProp, LONG_PRESS_START_TIME, TAP_OFFSET } from \"../utils/index.mjs\";\nimport { useTouch } from \"../composables/use-touch.mjs\";\nimport { raf, useEventListener, useRect } from \"@vant/use\";\nimport { Image } from \"../image/index.mjs\";\nimport { Loading } from \"../loading/index.mjs\";\nimport { SwipeItem } from \"../swipe-item/index.mjs\";\nconst getDistance = (touches) => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\nconst getCenter = (touches) => ({\n  x: (touches[0].clientX + touches[1].clientX) / 2,\n  y: (touches[0].clientY + touches[1].clientY) / 2\n});\nconst bem = createNamespace(\"image-preview\")[1];\nconst longImageRatio = 2.6;\nvar stdin_default = defineComponent({\n  props: {\n    src: String,\n    show: Boolean,\n    active: Number,\n    minZoom: makeRequiredProp(numericProp),\n    maxZoom: makeRequiredProp(numericProp),\n    rootWidth: makeRequiredProp(Number),\n    rootHeight: makeRequiredProp(Number),\n    disableZoom: Boolean,\n    closeOnClickOverlay: Boolean\n  },\n  emits: [\"scale\", \"close\", \"longPress\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const state = reactive({\n      scale: 1,\n      moveX: 0,\n      moveY: 0,\n      moving: false,\n      zooming: false,\n      initializing: false,\n      imageRatio: 0\n    });\n    const touch = useTouch();\n    const imageRef = ref();\n    const swipeItem = ref();\n    const vertical = ref(false);\n    const isLongImage = ref(false);\n    let initialMoveY = 0;\n    const imageStyle = computed(() => {\n      const {\n        scale,\n        moveX,\n        moveY,\n        moving,\n        zooming,\n        initializing\n      } = state;\n      const style = {\n        transitionDuration: zooming || moving || initializing ? \"0s\" : \".3s\"\n      };\n      if (scale !== 1 || isLongImage.value) {\n        style.transform = `matrix(${scale}, 0, 0, ${scale}, ${moveX}, ${moveY})`;\n      }\n      return style;\n    });\n    const maxMoveX = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;\n        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);\n      }\n      return 0;\n    });\n    const maxMoveY = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;\n        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);\n      }\n      return 0;\n    });\n    const setScale = (scale, center) => {\n      var _a;\n      scale = clamp(scale, +props.minZoom, +props.maxZoom + 1);\n      if (scale !== state.scale) {\n        const ratio = scale / state.scale;\n        state.scale = scale;\n        if (center) {\n          const imageRect = useRect((_a = imageRef.value) == null ? void 0 : _a.$el);\n          const origin = {\n            x: imageRect.width * 0.5,\n            y: imageRect.height * 0.5\n          };\n          const moveX = state.moveX - (center.x - imageRect.left - origin.x) * (ratio - 1);\n          const moveY = state.moveY - (center.y - imageRect.top - origin.y) * (ratio - 1);\n          state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n          state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n        } else {\n          state.moveX = 0;\n          state.moveY = isLongImage.value ? initialMoveY : 0;\n        }\n        emit(\"scale\", {\n          scale,\n          index: props.active\n        });\n      }\n    };\n    const resetScale = () => {\n      setScale(1);\n    };\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n      setScale(scale, scale === 2 || isLongImage.value ? {\n        x: touch.startX.value,\n        y: touch.startY.value\n      } : void 0);\n    };\n    let fingerNum;\n    let startMoveX;\n    let startMoveY;\n    let startScale;\n    let startDistance;\n    let lastCenter;\n    let doubleTapTimer;\n    let touchStartTime;\n    let isImageMoved = false;\n    const onTouchStart = (event) => {\n      const {\n        touches\n      } = event;\n      fingerNum = touches.length;\n      if (fingerNum === 2 && props.disableZoom) {\n        return;\n      }\n      const {\n        offsetX\n      } = touch;\n      touch.start(event);\n      startMoveX = state.moveX;\n      startMoveY = state.moveY;\n      touchStartTime = Date.now();\n      isImageMoved = false;\n      state.moving = fingerNum === 1 && (state.scale !== 1 || isLongImage.value);\n      state.zooming = fingerNum === 2 && !offsetX.value;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(touches);\n      }\n    };\n    const onTouchMove = (event) => {\n      const {\n        touches\n      } = event;\n      touch.move(event);\n      if (state.moving) {\n        const {\n          deltaX,\n          deltaY\n        } = touch;\n        const moveX = deltaX.value + startMoveX;\n        const moveY = deltaY.value + startMoveY;\n        if ((moveX > maxMoveX.value || moveX < -maxMoveX.value) && !isImageMoved && touch.isHorizontal()) {\n          state.moving = false;\n          return;\n        }\n        isImageMoved = true;\n        preventDefault(event, true);\n        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n      }\n      if (state.zooming) {\n        preventDefault(event, true);\n        if (touches.length === 2) {\n          const distance = getDistance(touches);\n          const scale = startScale * distance / startDistance;\n          lastCenter = getCenter(touches);\n          setScale(scale, lastCenter);\n        }\n      }\n    };\n    const checkTap = (event) => {\n      var _a;\n      if (fingerNum > 1) {\n        return;\n      }\n      const {\n        offsetX,\n        offsetY\n      } = touch;\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET) {\n        if (deltaTime < TAP_TIME) {\n          if (doubleTapTimer) {\n            clearTimeout(doubleTapTimer);\n            doubleTapTimer = null;\n            toggleScale();\n          } else {\n            if (!props.closeOnClickOverlay && event.target === ((_a = swipeItem.value) == null ? void 0 : _a.$el)) {\n              return;\n            }\n            doubleTapTimer = setTimeout(() => {\n              emit(\"close\");\n              doubleTapTimer = null;\n            }, TAP_TIME);\n          }\n        } else if (deltaTime > LONG_PRESS_START_TIME) {\n          emit(\"longPress\");\n        }\n      }\n    };\n    const onTouchEnd = (event) => {\n      let stopPropagation = false;\n      if (state.moving || state.zooming) {\n        stopPropagation = true;\n        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {\n          stopPropagation = false;\n        }\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);\n            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);\n            state.zooming = false;\n          }\n          state.moving = false;\n          startMoveX = 0;\n          startMoveY = 0;\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          const maxZoom = +props.maxZoom;\n          if (state.scale > maxZoom) {\n            setScale(maxZoom, lastCenter);\n          }\n        }\n      }\n      preventDefault(event, stopPropagation);\n      checkTap(event);\n      touch.reset();\n    };\n    const resize = () => {\n      const {\n        rootWidth,\n        rootHeight\n      } = props;\n      const rootRatio = rootHeight / rootWidth;\n      const {\n        imageRatio\n      } = state;\n      vertical.value = state.imageRatio > rootRatio && imageRatio < longImageRatio;\n      isLongImage.value = state.imageRatio > rootRatio && imageRatio >= longImageRatio;\n      if (isLongImage.value) {\n        initialMoveY = (imageRatio * rootWidth - rootHeight) / 2;\n        state.moveY = initialMoveY;\n        state.initializing = true;\n        raf(() => {\n          state.initializing = false;\n        });\n      }\n      resetScale();\n    };\n    const onLoad = (event) => {\n      const {\n        naturalWidth,\n        naturalHeight\n      } = event.target;\n      state.imageRatio = naturalHeight / naturalWidth;\n      resize();\n    };\n    watch(() => props.active, resetScale);\n    watch(() => props.show, (value) => {\n      if (!value) {\n        resetScale();\n      }\n    });\n    watch(() => [props.rootWidth, props.rootHeight], resize);\n    useEventListener(\"touchmove\", onTouchMove, {\n      target: computed(() => {\n        var _a;\n        return (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      })\n    });\n    return () => {\n      const imageSlots = {\n        loading: () => _createVNode(Loading, {\n          \"type\": \"spinner\"\n        }, null)\n      };\n      return _createVNode(SwipeItem, {\n        \"ref\": swipeItem,\n        \"class\": bem(\"swipe-item\"),\n        \"onTouchstartPassive\": onTouchStart,\n        \"onTouchend\": onTouchEnd,\n        \"onTouchcancel\": onTouchEnd\n      }, {\n        default: () => [slots.image ? _createVNode(\"div\", {\n          \"class\": bem(\"image-wrap\")\n        }, [slots.image({\n          src: props.src\n        })]) : _createVNode(Image, {\n          \"ref\": imageRef,\n          \"src\": props.src,\n          \"fit\": \"contain\",\n          \"class\": bem(\"image\", {\n            vertical: vertical.value\n          }),\n          \"style\": imageStyle.value,\n          \"onLoad\": onLoad\n        }, imageSlots)]\n      });\n    };\n  }\n});\nexport {\n  stdin_default as default\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}